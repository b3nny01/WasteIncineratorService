<!DOCTYPE html>
<html>

<head>
    <title>sprint1.md</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    
<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

</head>

<body>
    <link rel="stylesheet" type="text/css" href="resources/css/custom.css" />  
<h1 id="waste-incinerator-service">Waste Incinerator Service</h1>
<h2 id="sprint-info">Sprint info</h2>
<table>
<tr><th>Sprint name</th><td>Sprint 1</td></tr>
<tr><th>Previous sprint</th><td><a href="/WIS_Sprint0">Sprint 0</a></td></tr>
<tr><th>Next sprint</th><td></td></tr>
<tr><th>QAK model</th><td><a href="../src/sprint1.qak">sprint1.qak</a></td></tr>
<tr><th>Developed by</th><td>Alessio Benenati<br/>Giulia Fattori</td></tr>
</table>       
<h2 id="sprint-starting-condition-and-goals">Sprint Starting Condition and Goals</h2>
<p>In the previous sprint we focused on requirements analysis and we produced a simple base archictecture of what could be inferred by the assignement text.
in this sprint we will focus on the relationship between WIS and OpRobot, our goals are</p>
<ul>
<li>finding the best way to divide the buisness logic between the OpRobot and the WIS actor</li>
<li>consequently choosing the right model (<strong>Actor</strong> or <strong>POJO</strong>) for the OpRobot</li>
<li>producing a simple prototype of the system reproducing the functioning of this two entities</li>
</ul>
<h2 id="problem-analysis">Problem Analysis</h2>
<p>Questa sezione ha come scopo definire la relazione che sussiste tra WIS e OpRobot, in particolare come suddividere la business logic tra questi due componenti e di conseguenza decidere come classificare OpRobot (POJO o Actor). Al termine di questo Sprint sara' disponibile un primo prototipo del sistema funzionante.</p>
<h3 id="wis-and-oprobot">WIS and OpRobot</h3>
<p>Based on the requirements, we understand that the code for controlling the basic robot is provided by the client. Specifically, the basic robot is modeled as a service that can be interacted with through messages such as <code>moverobot: moverobot(TARGETX, TARGETY)</code> after engagement.</p>
<p>The BasicRobot autonomously handles movement requests to specific coordinates using an internal representation of the ServiceArea as a set of cells with a size of DR. Therefore, it is the responsibility of the WIS to store the coordinates of each point of interest in order to control the BasicRobot.</p>
<p>It remains to be determined whether it is truly necessary to model the OpRobot, or if its responsibilities can be incorporated into the WIS. Introducing an additional actor, OpRobot, which controls the basic robot and is managed by the WIS, would not significantly improve the isolation of responsibilities. On the contrary, it could create confusion regarding the division of business logic among the various actors.</p>
<p>For this reason, at this stage, it is more practical to keep the business logic concentrated solely within the WIS, without modeling the OpRobot. However, this decision may be subject to change in the future if the analysis reveals new responsibilities for the WIS, making it necessary to separate tasks (Single Responsibility Principle).</p>
<h3 id="system-observability">System Observability</h3>
<p>da requisiti il WIS necessita di essere notificato in caso di determinati cambiamenti di stato del sistema (ad esempio l' endOfBurining dell'Incinerator).
Questo sottointende la necessità di modellare una qualche forma di comunicazione tra i vari componenti del sistema (Scale, MonitoringDevice ed Incinerator) ed il WIS stesso.
una prima soluzione potrebbe essere quella di prevedere un serie di richieste di stato effettuate dal WIS ai singoli componenti, tuttavia questo approccio si rivela inefficace in quanto prevede che il WIS 'sprechi' molto tempo di calcolo nell'interrogare i vari componenti.
risulta invece meno dispendioso adottare il pattern observer facendo sì che siano i componenti stessi ad avvisare il WIS in caso di cambiamenti di stato.
Tuttavia il compito del WIS consiste principalmente nel pilotare il BasicRobot, pertanto non è interessato a tutte le modifche di stato del sistema, gli basta sapere che le condizioni per dare inizio ad un ciclo di movimento dell'OpRobot siano verificate per questo motivo si consiglia l'introduzione di un nuovo attore WIS_Observer che si occupi di osservare il sistema per intero e di notificare il WIS in merito alla validità tali condizioni</p>
<h2 id="future-sprints">Future Sprints</h2>

</body>

</html>