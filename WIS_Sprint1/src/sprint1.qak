System wis_system  

// NOTE: message types have been chosen only to produce a first working prototype of the system so they are not 
// fixed and have to be discussed in future sprints

Dispatch	actor_state					: actor_state(P,V)
Dispatch 	incinerator_activation		: incinerator_activation(A)

Request 	conditions_verified_req		: conditions_verified_req(N)
Reply 		conditions_verified_repl	: conditions_verified_repl(R) for conditions_verified_req

Event load_rp						: load_rp(N)
Event unload_ash					: unload_rp(N)

Request burn_req					: burn_req(N)
Reply 	burn_repl					: burn_repl(N) for burn_req

//Inglobamento endosimbitico di robotpos 

Request engage        : engage(OWNER, STEPTIME)	
Reply   engagedone    : engagedone(ARG)    for engage
Reply   engagerefused : engagerefused(ARG) for engage

Dispatch disengage    : disengage(ARG)

Request moverobot    :  moverobot(TARGETX, TARGETY)  
Reply moverobotdone  :  moverobotok(ARG)                    for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot
 
 
Context ctx_wis ip [ host="localhost" port=8022]  
Context ctx_basic_robot ip [host= "127.0.0.1" port=8020]

ExternalQActor robotpos context ctx_basic_robot
ExternalQActor engager context ctx_basic_robot

// NOTE: the following model is already working but yet a prototype, some parts are still extremely simplified
// (for instance OpRobot movements) and some are completely unimplemented (error handlingW	)

QActor incinerator context ctx_wis{     
 	[#
 		var ACTIVE	   = false;
 		var BURNING    = false;
 		var BURNOUT_FREE = true;		
 	 #]
 	 
 	State s0 initial{ 
 		println("$name starts") color red
		delay 500
		updateResource  [# "actor_state(incinerator_burning,$BURNING)" #]
	}Goto idle
	
	State idle{
		println("$name: idle") color red
	}Transition t0
	whenMsg incinerator_activation -> handle_activation
	whenRequest burn_req -> handle_burn_req
	
	State handle_activation{
		onMsg (incinerator_activation:incinerator_activation(A)){
			[#
				ACTIVE=payloadArg(0).toBoolean()
			#]
			updateResource  [# "actor_state(incinerator_active,$ACTIVE)" #]
		}
		println("$name: handling activation request, active: $ACTIVE") color red
	} Goto idle
	
	State handle_burn_req{
		[#
			var R=false
			if(!BURNING && ACTIVE){
				BURNING=true
				R=true
			}
			
		#]
		println("$name: handling burn request, result:$BURNING") color red

		if[# BURNING #]{
			updateResource  [# "actor_state(incinerator_burning,$BURNING)" #]
			delay 5000 // burning simulation
			[# 
				BURNING=false
				BURNOUT_FREE=false
			#]
			updateResource  [# "actor_state(incinerator_burning,$BURNING)" #]
		}
		replyTo burn_req with burn_repl : burn_repl($R)
	}Goto idle
}
 
QActor scale context ctx_wis{
 	[#
 		var ROLL_PACKETS=10
 	 #]
 	 
 	State s0 initial{ 
 		println("$name starts") color blue
		delay 500
		updateResource [# "actor_state(waste_storage_rps,$ROLL_PACKETS)" #]
	}Goto idle
	
	State idle{
		println("$name: idle") color blue
	}Transition t0 
	whenEvent load_rp -> handle_load_rp 
	
	State handle_load_rp{
		[#
			var R=false
			if(ROLL_PACKETS>0){
				ROLL_PACKETS--
			}
		#]
		updateResource [# "actor_state(waste_storage_rps,$ROLL_PACKETS)" #]
	}Goto idle
	
 }
 
QActor monitoring_device context ctx_wis{
 	[#
 		var ASH_LEVEL=0
 		val MAX_ASH_LEVEL=3
 	 #]
 	
 	 State s0 initial{ 
 		println("$name starts") color magenta
		delay 500
		updateResource [# "actor_state(ash_storage_level,$ASH_LEVEL)" #]
	} Goto idle
	
		
	State idle{
		println("$name: idle") color magenta
	}Transition t0 
	whenEvent unload_ash -> handle_unload_ash
	
	State handle_unload_ash{
		[#
			var R=false
			if(ASH_LEVEL<MAX_ASH_LEVEL){
				R=true
				ASH_LEVEL++
			}
			
		#]
		println("$name: handling ash request, result:$R") color magenta
		
		updateResource [# "actor_state(ash_storage_level,$ASH_LEVEL)" #]
	}Goto idle
	
}

QActor wis context ctx_wis {
	import "main.resources.position.Position"
	[#
		var OK=false;
		val LOCATIONS=mapOf("home" 			to Position(0,0),
							"waste storage" to Position(0,4),
							"burn in"		to Position(3,1),
							"burn out"		to Position(5,3),
							"ash storage"	to Position(6,4)
		)
	#]
	State s0 initial{ 
 		println("$name starts") color green
	}Goto engage_robot 

	State engage_robot{
		delay 500
		println("$name: engaging robot") color yellow
		request engager -m engage:engage(wis,330)
	}Transition t0 whenReply engagedone -> handle_engage_robot_repl
	
	State handle_engage_robot_repl{
		[#
			OK = false	
		#]
		onMsg (engagedone:engagedone(ARG)){
			[#
				OK=true	
			#]
		}
		println("$name: robot engaged: $OK") color yellow
	} Goto activate_incinerator if [# OK #] else engage_robot
	
	State activate_incinerator{
		[#
			val AR=true	
		#]
		println("$name: activating incinerator") color yellow
		forward incinerator -m incinerator_activation : incinerator_activation($AR)
	}Goto check_start_conditions
	
	State check_start_conditions{
		delay 500
		println("$name: checking conditions") color green
		request wis_state_observer -m conditions_verified_req:conditions_verified_req
	}Transition t0
	whenReply conditions_verified_repl->handle_start_conditions_verified_repl
	
	State handle_start_conditions_verified_repl{
		onMsg(conditions_verified_repl:conditions_verified_repl(R)){
			[#
				OK=payloadArg(0).toBoolean()
			#]
		}
		println("$name: conditions verified: $OK") color green
	}Goto move_to_waste_storage if [# OK #] else check_start_conditions
	
	
	// loading an rp
	State move_to_waste_storage{
		[#
			val DEST="waste storage"
			val X=LOCATIONS[DEST]?.x
			val Y=LOCATIONS[DEST]?.y
		#]
		println("$name: moving to $DEST...") color green
		request robotpos -m moverobot:moverobot($X,$Y)
	} Transition t0
	whenReply moverobotdone -> load_rp
	whenReply moverobotfailed -> move_to_waste_storage
	
	State load_rp{
		println("$name: loading an rp") color green
		emit load_rp : load_rp
		delay 1000
	}Goto move_to_burn_in
		
	// burning the rp
	State move_to_burn_in{
		[#
			val DEST="burn in"
			val X=LOCATIONS[DEST]?.x
			val Y=LOCATIONS[DEST]?.y
		#]
		println("$name: moving to $DEST...") color green
		request robotpos -m moverobot:moverobot($X,$Y)
	}Transition t0
	whenReply moverobotdone -> request_to_burn
	whenReply moverobotfailed -> move_to_burn_in 
	
	State request_to_burn{
		println("$name: requesting to burn an rp") color green
		request incinerator -m burn_req : burn_req
		delay 1000

	}Goto return_to_home
	
	State return_to_home{
		[#
			val DEST="home"
			val X=LOCATIONS[DEST]?.x
			val Y=LOCATIONS[DEST]?.y
		#]
		println("$name: moving to $DEST...") color green
		request robotpos -m moverobot:moverobot($X,$Y) 
	}
	Transition t0
	whenReply moverobotdone -> wait_for_burn_repl
	whenReply moverobotfailed -> return_to_home
	
	State wait_for_burn_repl{
		println("$name: waiting end of burning...") color green
	}Transition t0
	whenReply burn_repl -> handle_burn_repl
	
	State handle_burn_repl{
		[#
			OK=payloadArg(0).toBoolean()	
		#]
		println("$name: burn request result: $OK") color green
	}Goto move_to_burn_out
	
	State move_to_burn_out{
		[#
			val DEST="burn out"
			val X=LOCATIONS[DEST]?.x
			val Y=LOCATIONS[DEST]?.y
		#]
		println("$name: moving to $DEST...") color green
		request robotpos -m moverobot:moverobot($X,$Y) 
	}Transition t0
	whenReply moverobotdone->load_ash
	whenReply moverobotfailed->move_to_burn_out
	
	State load_ash{
		println("$name: loading ash") color green
		delay 1000
	}Goto move_to_ash_storage
	
	// unload ashes
	State move_to_ash_storage{
		[#
			val DEST="ash storage"
			val X=LOCATIONS[DEST]?.x
			val Y=LOCATIONS[DEST]?.y
		#]
		println("$name: moving to $DEST...") color green
		request robotpos -m moverobot:moverobot($X,$Y)
	}Transition t0
	whenReply moverobotdone -> unload_ash
	
	 State unload_ash{
	 	println("$name: unloading ash...") color green
	 	emit unload_ash : unload_ash
	 	delay 1000
	 }Goto check_continue_conditions
	 
	 State check_continue_conditions{
		println("$name: checking conditions") color green
		request wis_state_observer -m conditions_verified_req:conditions_verified_req
	}Transition t0
	whenReply conditions_verified_repl->handle_continue_conditions_verified_repl
	
	State handle_continue_conditions_verified_repl{
		onMsg(conditions_verified_repl:conditions_verified_repl(R)){
			[#
				OK=payloadArg(0).toBoolean()
			#]
		}
		println("$name: conditions verified: $OK") color green
	}Goto move_to_waste_storage if [#OK#] else move_to_home
	
	State move_to_home{
		[#
			val DEST="home"
			val X=LOCATIONS[DEST]?.x
			val Y=LOCATIONS[DEST]?.y
		#]
		println("$name: moving to $DEST...") color green
		request robotpos -m moverobot:moverobot($X,$Y)
	}Transition t0
	whenReply moverobotdone -> check_start_conditions
	whenReply moverobotfailed -> move_to_home
}

QActor wis_state_observer context ctx_wis{
 	[#
 		var RP = 0
 		var A = false
 		var B = false 
 		var L = 0
 		val LMAX = 3
 	
 	#]
 	
 	State s0 initial{ 
 		println("$name starts") color yellow
		observeResource scale msgid actor_state
		observeResource incinerator msgid actor_state
		observeResource monitoring_device msgid actor_state
		
	} Goto waiting_for_updates
	
	State waiting_for_updates{
		println("$name: waiting for updates...") color yellow
	}Transition t0 
		whenMsg actor_state -> update_state
		whenRequest conditions_verified_req -> handle_conditions_verified_req
		
	State update_state{
		onMsg(actor_state:actor_state(P,V)){
			[#
				val P=payloadArg(0);
				val V=payloadArg(1);
				when (P){
					"incinerator_active" -> A=V.toBoolean()
					"incinerator_burning"-> B=V.toBoolean()
					"waste_storage_rps"  -> RP=V.toInt()
					"ash_storage_level"  -> L=V.toInt()
				}
			#]
			println("$name: $P updated") color yellow
		}
	} Goto waiting_for_updates


	State handle_conditions_verified_req{
		[#
			val RESULT=(RP>0) && (A && !B) && (L<LMAX)
		#]
		println("$name: current state { RP:$RP, B:$B, L:$L }, conditions verified: $RESULT") color yellow
		replyTo conditions_verified_req with conditions_verified_repl : conditions_verified_repl($RESULT)
	}Goto waiting_for_updates
	
 }

 
 