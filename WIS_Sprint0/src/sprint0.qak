System wis_system

Dispatch actor_state		: actor_state(P,V)
Request conditions_verified_req		: conditions_verified_req(N)
Reply conditions_verified_repl		: conditions_verified_repl(R) for conditions_verified_req

//Request waste_storage_state_request : waste_storage_state_request(N)
//Reply   waste_storage_state_reply	: waste_storage_state_reply(N) for waste_storage_state_request
//
//Request ash_storage_state_request   : ash_storage_state_request(N)
//Reply   ash_storage_state_reply	    : ash_storage_state_reply(N) for ash_storage_state_request
//
//Request incinerator_state_request   : incinerator_state_request(N)
//Reply   incinerator_state_reply	    : incinerator_state_reply(B,BOF) for incinerator_state_request

Request rp_request					: rp_request(N)
Reply   rp_reply					: rp_reply(N) for rp_request

Event end_of_burning				: end_of_burning(N)

// commands
Request  cmd_move				    : cmd_move(D)					 	 					
Request  cmd_add_rp					: cmd_add_rp(N)						 
Request  cmd_remove_rp				: cmd_remove_rp(N)						 
Request  cmd_add_ash				: cmd_add_ash(N)						 
Request  cmd_remove_ash				: cmd_remove_ash(N)
Request	 cmd_burn					: cmd_burn(N)
						 
Reply	 cmd_reply					: cmd_reply(R)





Context ctx_wis ip [ host="localhost" port=8020]  

QActor incinerator context ctx_wis{     
 	[#
 		var BURNING    = false;
 		var BURNOUT_FREE = true;		
 	 #]
 	 
 	State s0 initial{ 
 		println("$name starts") color red
		delay 500
		updateResource  [# "actor_state(incinerator_burning,$BURNING)" #]
	}Goto idle
	
	State idle{
		println("$name: idle") color red
	}
}
 
QActor waste_storage context ctx_wis{
 	[#
 		var ROLL_PACKETS=10
 	 #]
 	 
 	State s0 initial{ 
 		println("$name starts") color blue
		delay 500
		updateResource [# "actor_state(waste_storage_rps,$ROLL_PACKETS)" #]
	}Goto idle
	
	State idle{
		println("$name: idle") color blue
	}
	
 }
 
QActor ash_storage context ctx_wis{
 	[#
 		var ASH_LEVEL=0
 	 #]
 	
 	 State s0 initial{ 
 		println("$name starts") color magenta
		delay 500
		updateResource [# "actor_state(ash_storage_level,$ASH_LEVEL)" #]
	} Goto idle
	
		
	State idle{
		println("$name: idle") color blue
	}
}


QActor op_robot context ctx_wis{
	State s0 initial{ 
 		println("$name starts") color green
		delay 500
	}Goto idle
	
	State idle{
		println("$name: idle") color green
	}Transition t0
	 whenRequest cmd_move -> handle_cmd_move
	 whenRequest cmd_add_rp -> handle_cmd_add_rp
		
		
	// PLACEHOLDER	
	State handle_cmd_move{
		onMsg(cmd_move:cmd_move(DEST))
		{ 
			[#
				val DEST=payloadArg(0)	
			#]
			println("$name: moving to $DEST...") color green
			// TODO: implement movement logic
			delay 2000
		}
	}Goto cmd_move_reply 
	
	State cmd_move_reply{
		[#
			val RESULT=true
		#]
		println("$name: end of movement") color green
		replyTo cmd_move with cmd_reply:cmd_reply($RESULT)
	}Goto idle
	
	
	
	State handle_cmd_add_rp{
		[#
			val RESULT=true
		#]
		println("$name: loading an RP") color green
		replyTo cmd_add_rp with cmd_reply:cmd_reply($RESULT) 
	}
	
	
}

QActor waste_incinerator_service context ctx_wis{
 	[#
 		var RP = 0
 		var B = false
 		var L = 0
 		val LMAX = 3
 	
 	#]
 	
 	State s0 initial{ 
 		println("$name starts") color yellow
		observeResource waste_storage msgid actor_state
		observeResource incinerator msgid actor_state
		observeResource ash_storage msgid actor_state  
		
	} Goto waiting_for_updates
	
	State waiting_for_updates{
		println("$name: waiting for updates...") color yellow
	}Transition t0 
		whenMsg actor_state -> update_state
		whenRequest conditions_verified_req -> handle_conditions_verified_req
		
	State update_state{
		printCurrentMessage
		onMsg(actor_state:actor_state(P,V)){
			[#
				val P=payloadArg(0);
				val V=payloadArg(1);
				when (P){
					"incinerator_burning"-> B=V.toBoolean()
					"waste_storage_rps"  -> RP=V.toInt()
					"ash_storage_level"  -> L=V.toInt()
				}
			#]
			println("$name: $P updated") color yellow
		}
	} Goto waiting_for_updates


	State handle_conditions_verified_req{
		[#
			val RESULT=(RP>0) && (!B) && (L<LMAX)
		#]
		println("$name: current state { RP:$RP, B:$B, L:$L }, conditions verified: $RESULT")
		replyTo conditions_verified_req with conditions_verified_repl : conditions_verified_repl($RESULT)
	}
	
 }


//QActor waste_incinerator_service context ctx_wis{
// 	[#
// 		var ok=false;
// 	
// 	#]
// 	
// 	State s0 initial{ 
// 		println("$name starts") color yellow
//		delay 500
//	} Goto request_waste_storage_state
//	
//
//	// waste storage check
//	State request_waste_storage_state{
//		println("$name: requesting waste storage state") color yellow
//		request waste_storage -m waste_storage_state_request:waste_storage_state_request
//	}Transition t0
//	whenReply waste_storage_state_reply -> handle_waste_storage_state_reply
//	
//	State handle_waste_storage_state_reply{
//		onMsg(waste_storage_state_reply:waste_storage_state_reply(N)){
//			[#
//				val ROLL_PACKETS = payloadArg(0).toInt()
//				ok = ROLL_PACKETS>0
//			#]
//			println("$name: waste storage contains $ROLL_PACKETS roll packets") color yellow
//		}
//	}Goto request_ash_storage_state if [# ok #] else handle_waste_storage_empty
//	
//	State handle_waste_storage_empty{
//		println("$name: waste storage is empty, waiting...") color yellow
//	}
//	
//	
//	// ash storage check
//	State request_ash_storage_state{
//		println("$name: requesting ash storage state") color yellow
//		request ash_storage -m ash_storage_state_request:ash_storage_state_request
//	}Transition t0
//	whenReply ash_storage_state_reply -> handle_ash_storage_state_reply
//	
//	State handle_ash_storage_state_reply{
//		onMsg(ash_storage_state_reply:ash_storage_state_reply(L)){
//			[#
//				val ASH_LEVEL_PERC = payloadArg(0).toFloat();
//				ok = ASH_LEVEL_PERC<100.0
//			#]
//			println("$name: ash storage is $ASH_LEVEL_PERC% full") color yellow
//		}
//	}Goto request_incinerator_state if [# ok #] else handle_ash_storage_empty
//	
//	State handle_ash_storage_empty{
//		println("$name: ash storage is full, waiting...") color yellow
//	}
//	
//	// incinerator check 
//	State request_incinerator_state{ 
//		println("$name: requesting incinerator state") color yellow
//		request incinerator -m incinerator_state_request:incinerator_state_request
//	}Transition t0
//	whenReply incinerator_state_reply -> handle_incinerator_state_reply
//	
//	State handle_incinerator_state_reply{
//		onMsg(incinerator_state_reply:incinerator_state_reply(B,BOF)){
//			[#
//				val BURNING = payloadArg(0).toBoolean();
//				val BURNOUT_FREE = payloadArg(1).toBoolean();
//				ok = (!BURNING) && BURNOUT_FREE
//			#]
//			println("$name: incinerator burning: $BURNING, burnout free: $BURNOUT_FREE ") color yellow
//		}
//	}Goto op_robot_to_waste_storage if [# ok #] else handle_incinerator_not_available
//	
//	State handle_incinerator_not_available{
//		println("$name: incinerator not available, waiting...") color yellow
//	}
//	
//	// opRobot to waste storage
//	State op_robot_to_waste_storage{
//		[#
//			val DEST="waste_storage"
//			
//		#]
//		println ("$name: asking robot to move to $DEST") color yellow
//		request op_robot -m cmd_move:cmd_move($DEST)
//		
//	}Transition t0
//	whenReply cmd_reply -> remove_rp_from_waste_storage //TODO: check reply result
//	
//	// loading an RP into opRobot
//	State remove_rp_from_waste_storage{
//		request ash_storage -m cmd_remove_ash: cmd_remove_ash 
//	}Transition t0
//	whenReply cmd_reply -> add_rp_to_op_robot
//	
//	State add_rp_to_op_robot{
//		request op_robot -m cmd_add_rp: cmd_add_rp
//	}Transition t0
//	whenReply cmd_reply -> op_robot_to_incinerator
//	
//	// opRobot to incinerator
//	State op_robot_to_incinerator{
//		[#
//			val DEST="incinerator"
//			
//		#]
//		println ("$name: asking robot to move to $DEST") color yellow
//		request op_robot -m cmd_move:cmd_move($DEST)
//		
//	}Transition t0
//	whenReply cmd_reply -> end//TODO: check reply result
//	
//	
//	
//	
//	
//	
//	State end{
//		println("$name: end") color yellow
//	}
//
//	
//	
// }
