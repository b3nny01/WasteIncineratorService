System wis_system

Request waste_storage_state_request : waste_storage_state_request(N)	 ""
Reply   waste_storage_state_reply	: waste_storage_state_reply(N)										for waste_storage_state_request	 ""

Request ash_storage_state_request   : ash_storage_state_request(N)	 	 ""
Reply   ash_storage_state_reply	    : ash_storage_state_reply(N)
										for ash_storage_state_request	 ""

Request incinerator_state_request   : incinerator_state_request(N)	 	 ""
Reply   incinerator_state_reply	    : incinerator_state_reply(B,BOF) 
										for incinerator_state_request	 ""

Request rp_request					: rp_request(N)						 ""	
Reply   rp_reply					: rp_reply(N)
										for rp_request		 			 ""

// for now dispatches, maybe they'll become requests
Dispatch move_to			    	: move_to(X,Y)						 ""
Dispatch load_rp					: load_rp(N)						 ""
Dispatch unload_rp					: unload_rp(N)						 ""
Dispatch load_ash					: load_ash(N)						 ""
Dispatch unload_ash					: unload_ash(N)						 ""
 
Context ctx_wis ip [ host="localhost" port=8020] 

QActor incinerator context ctx_wis{     
 	[#
 		var BURNING    = false;
 		var BURNOUT_FREE = true;		
 	 #]
 	 
 	State s0 initial{ 
 		println("$name starts") color red
		delay 500
	}Goto idle
	
	State idle{
		println("$name: idle") color red
	}Transition t0 
		whenRequest incinerator_state_request->handle_state_request
	
	State handle_state_request{
		println("$name: handling state request") color blue
		replyTo incinerator_state_request with incinerator_state_reply : incinerator_state_reply($BURNING,$BURNOUT_FREE )
	}Goto idle
	  
 }
 
 QActor waste_storage context ctx_wis{
 	[#
 		var ROLL_PACKETS=10
 	 #]
 	 
 	State s0 initial{ 
 		println("$name starts") color blue
		delay 500
	}Goto idle
	
	State idle{
		println("$name: idle") color blue
	}Transition t0 
		whenRequest waste_storage_state_request->handle_state_request
	
	State handle_state_request{
		println("$name: handling state request") color blue
		replyTo waste_storage_state_request with waste_storage_state_reply : waste_storage_state_reply($ROLL_PACKETS)
	}Goto idle
	
 }
 
 QActor ash_storage context ctx_wis{
 	[#
 		var ASH_LEVEL=0
 		val MAX_ASH_LEVEL=10
 	 #]
 	
 	 State s0 initial{ 
 		println("$name starts") color magenta
		delay 500
	} Goto idle
	
		
	State idle{
		println("$name: idle") color blue
	}Transition t0 
		whenRequest ash_storage_state_request->handle_state_request
	
	State handle_state_request{
		println("$name: handling state request") color blue
		[#
			val ASH_LEVEL_PERC=ASH_LEVEL.toFloat()/MAX_ASH_LEVEL* 100
		#]
		replyTo ash_storage_state_request with ash_storage_state_reply : ash_storage_state_reply($ASH_LEVEL_PERC)
	}Goto idle
	
}


QActor op_robot context ctx_wis{
	State s0 initial{ 
 		println("$name starts") color green
		delay 500
	}Goto idle
	
	State idle{
		println("$name: idle") color green
	}Transition t0
	 whenRequest move_request -> handle_move_request
		
		
	// PLACEHOLDER	
	State handle_move_request{
		[#
			val RESULT=true
		#]
		println("$name: moving...") color green
		delay 2000
		println("$name: moved") color green
		replyTo move_request with move_reply($RESULT)
	} 
	
	
	
	State request_rp{
		println("$name: requesting an RP") color green
		request	waste_storage -m rp_request:rp_request
	}Transition t0
		whenReply rp_reply->handle_rp_reply
	
	State handle_rp_reply{
		[#
			val RESULT=true
		#]
		println("$name: obtained an RP") color green
		replyTo move_request 
	} Goto 
	
	
	
}
 
 QActor waste_incinerator_service context ctx_wis{
 	[#
 		var ok=true;	
 	#]
 	
 	State s0 initial{ 
 		println("$name starts") color yellow
		delay 500
	}Goto request_waste_storage_state
	

	// waste storage check
	State request_waste_storage_state{
		println("$name: requesting waste storage state") color yellow
		request waste_storage -m waste_storage_state_request:waste_storage_state_request
	}Transition t0
	whenReply waste_storage_state_reply -> handle_waste_storage_state_reply
	
	State handle_waste_storage_state_reply{
		onMsg(waste_storage_state_reply:waste_storage_state_reply(N)){
			[#
				val ROLL_PACKETS = payloadArg(0).toInt()
				ok = ROLL_PACKETS>0
			#]
			println("$name: waste storage contains $ROLL_PACKETS roll packets") color yellow
		}
	}Goto request_ash_storage_state if [# ok #] else handle_waste_storage_empty
	
	State handle_waste_storage_empty{
		println("$name: waste storage is empty, waiting...") color yellow
	}
	
	
	// ash storage check
	State request_ash_storage_state{
		println("$name: requesting ash storage state") color yellow
		request ash_storage -m ash_storage_state_request:ash_storage_state_request
	}Transition t0
	whenReply ash_storage_state_reply -> handle_ash_storage_state_reply
	
	State handle_ash_storage_state_reply{
		onMsg(ash_storage_state_reply:ash_storage_state_reply(L)){
			[#
				val ASH_LEVEL_PERC = payloadArg(0).toFloat();
				ok = ASH_LEVEL_PERC<100.0
			#]
			println("$name: ash storage is $ASH_LEVEL_PERC% full") color yellow
		}
	}Goto request_incinerator_state if [# ok #] else handle_ash_storage_empty
	
	State handle_ash_storage_empty{
		println("$name: ash storage is full, waiting...") color yellow
	}
	
	// incinerator check 
	State request_incinerator_state{ 
		println("$name: requesting incinerator state") color yellow
		request incinerator -m incinerator_state_request:incinerator_state_request
	}Transition t0
	whenReply incinerator_state_reply -> handle_incinerator_state_reply
	
	State handle_incinerator_state_reply{
		onMsg(incinerator_state_reply:incinerator_state_reply(B,BOF)){
			[#
				val BURNING = payloadArg(0).toBoolean();
				val BURNOUT_FREE = payloadArg(1).toBoolean();
				ok = (!BURNING) && BURNOUT_FREE
			#]
			println("$name: incinerator burning: $BURNING, burnout free: $BURNOUT_FREE ") color yellow
		}
	}Goto handle_incinerator_not_available if [# ok #] else handle_incinerator_not_available
	
	State handle_incinerator_not_available{
		println("$name: incinerator not available, waiting...") color yellow
	}
	
	
 }
